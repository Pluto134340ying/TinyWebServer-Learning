此项目是基于 Linux 的轻量级多线程 Web 服务器，应用层实现了一个简单的 HTTP 服务器，利用多路 IO 复用，可以同时监听多个请求，使用线程池处理请求，使用模拟 proactor 模式，主线程负责监听，监听有事件之后，从 socket 中循环读取数据，然后将读取到的数据封装成一个请求对象放入队列。睡眠在请求队列上的工作线程被唤醒进行处理，使用状态机解析 HTTP 请求报文，实现 同步/异步 日志系统，记录服务器运行状态，并对系统进行了压力测试。


项⽬中搭建了⼀个半同步/反应堆线程池，在其中维护了⼀个请求队列，线程池中的主线程通过 epoll 来监听 socket，并且将请求队列中的任务分配给线程池中的⼯作线程，其中⼯作线程能够处理的任务分为⽇志输出、定时器处理⾮活动连接以及处理 HTTP 请求三种
这个框架图更加简洁明了。在 WebServer 中，许多 client 在 MainReactor 中得到连接请求的响应，并与 WebServer 建立具体的连接。然后通过一个叫 Acceptor 的组件接收新连接，并通过设计好的轮询算法派发给 SubReactor。在 SubReactor 中，对具体的连接进行读、编码、计算、解码和写操作（即对 client 请求的响应）。

调用 `TcpServer` 的 `start` 函数后，会在内部创建线程池。每个线程独立运行一个事件循环，即 SubReactor。MainReactor 从线程池中轮询获取 SubReactor，并派发新连接给它们。处理读写事件的 SubReactor 个数一般和 CPU 核心数相等。

### I/O模型

阻塞I/O，非阻塞I/O，信号驱动I/O和I/O复用都是同步I/O。同步I/O指内核向应用程序通知的是就绪事件，比如只通知有客户端连接，要求用户代码自行执行I/O操作，异步I/O是指内核向应用程序通知的是完成事件，比如读取客户端的数据后才通知应用程序，由内核完成I/O操作。

### Reactor模式：主线程只负责监听文件描述符上是否有事件发生，有的话通知工作线程，工作线程中会完成读写数据，接受新连接以及处理客户请求。同步IO

### Proactor模式：所有IO都交给主线程和内核处理，工作线程只负责业务逻辑。异步IO

**主从 Reactor 模型的优点：**

- 响应快，不必为单个同步事件所阻塞，虽然 Reactor 本身依然是同步的；
- 最大程度避免复杂的多线程及同步问题，并且避免多线程/进程的切换；
- 扩展性好，可以方便通过增加 Reactor 实例个数充分利用 CPU 资源；
- 复用性好，Reactor 模型本身与具体事件处理逻辑无关，具有很高的复用性。

---

许多 client 在访问 WebServer 时，并不是每个 client 都由一个服务端的线程/进程进行业务处理。在高并发（多个 client 同时访问服务端）场景中，这种方式不仅会影响服务端的响应速度，而且服务端本身可建立的线程/进程数有限，容易导致服务端崩溃。

因此，muduo 使用非阻塞的 poll/epoll（IO 多路复用）轮询监听（Reactor）是否有 SOCKET 读写 IO 事件，将 IO 事件的处理回调函数分发到线程池中，实现异步返回结果。其多线程编程模型采用 “one loop per thread + thread pool” 形式：

- 一个线程中有且仅有一个 EventLoop（即每个核的线程负责循环监听一组文件描述符的集合），该线程称为 IO 线程。
- 若长时间无事件发生，IO 线程将处于空闲状态，此时可利用 IO 线程执行额外任务（如通过定时器任务队列处理超时连接），这要求非阻塞的 poll/epoll 在无 IO 事件但有任务到来时能够被唤醒。

---

## HTTP

### HTTP 报文处理流程

1. 浏览器端发出 HTTP 连接请求，主线程创建 HTTP 对象接收请求并将所有数据读入对应 buffer，将该对象插入任务队列，工作线程从任务队列中取出一个任务进行处理。（本篇讲）
2. 工作线程取出任务后，调用 `process_read` 函数，通过主、从状态机对请求报文进行解析。（中篇讲）
3. 解析完之后，跳转 `do_request` 函数生成响应报文，通过 `process_write` 写入 buffer，返回给浏览器端。（下篇讲）

### HTTP 服务器中 epoll 的典型应用流程

以一个基于 epoll 的 HTTP 服务器为例，处理流程如下：

1. **初始化 epoll 实例**  
    创建 epoll 句柄（`epoll_create`），并将监听 socket（用于接受客户端连接）添加到 epoll 监控列表中（`epoll_ctl`）。

2. **接受客户端连接**  
    当监听 socket 触发 EPOLLIN 事件时，通过 `accept` 函数接受新的 HTTP 连接，得到客户端 socket，并将其设置为非阻塞模式，再通过 `epoll_ctl` 将该 socket 添加到 epoll 监控中。

3. **处理 IO 事件**  
    - 读取请求数据：当客户端 socket 触发 EPOLLIN 事件时，读取 HTTP 请求数据（如头部、Body），解析请求内容（路径、方法、参数等）。
    - 处理业务逻辑：根据请求内容调用后端服务（如数据库查询、文件读取），生成响应数据。
    - 发送响应数据：当响应数据准备好后，将客户端 socket 注册为 EPOLLOUT 事件，触发时通过 write 发送响应（若数据未一次性发送完毕，需分段处理并等待下次 EPOLLOUT 事件）。

4. **连接管理与复用**  
    处理完 HTTP 请求后，若开启 Keep-Alive（连接复用），则保持 socket 连接并重新注册到 epoll 中，等待下一次请求；否则关闭 socket 并从 epoll 中删除。通过 `epoll_ctl` 的修改操作（`EPOLL_CTL_MOD`）调整 socket 的事件监听类型（如从 EPOLLIN 切换为 EPOLLOUT）。

### http请求解析-主从状态机

从状态机负责读取报文的一行，主状态机负责对该行数据进行解析，主状态机内部调用从状态机，从状态机驱动主状态机。

CHECK_STATE_CONTENT，解析消息体，仅用于解析POST请求

### http请求响应

浏览器端发出HTTP请求报文，服务器端接收该报文并调用process_read对其进行解析，根据解析结果HTTP_CODE，进入相应的逻辑和模块。

其中，服务器子线程完成报文的解析与响应；主线程监测读写事件，调用read_once和http_conn::write完成数据的读取与发送。

响应报文分为两种，一种是请求文件的存在，通过io向量机制iovec，声明两个iovec，第一个指向m_write_buf，第二个指向mmap的地址m_file_address；一种是请求出错，这时候只申请一个iovec，指向m_write_buf。

服务器子线程调用process_write完成响应报文，随后注册epollout事件。
服务器主线程检测写事件，并调用http_conn::write函数将响应报文发送给浏览器端。

## 定时器

服务器主循环为每一个连接创建一个定时器，并对每个连接进行定时。另外，利用升序时间链表容器将所有定时器串联起来，若主循环接收到定时通知，则在链表中依次执行定时任务。

利用alarm函数周期性地触发SIGALRM信号，信号处理函数利用管道通知主循环，主循环接收到该信号后对升序链表上所有定时器进行处理，若该段时间内没有交换数据，则将该连接关闭，释放所占用的资源。

### 信号处理机制

信号的接收

接收信号的任务是由内核代理的，当内核接收到信号后，会将其放到对应进程的信号队列中，同时向进程发送一个中断，使其陷入内核态。注意，此时信号还只是在队列中，对进程来说暂时是不知道有信号到来的。

信号的检测

进程从内核态返回到用户态前进行信号检测

进程在内核态中，从睡眠状态被唤醒的时候进行信号检测

进程陷入内核态后，有两种场景会对信号进行检测：

当发现有新信号时，便会进入下一步，信号的处理。

信号的处理

( 内核 )信号处理函数是运行在用户态的，调用处理函数前，内核会将当前内核栈的内容备份拷贝到用户栈上，并且修改指令寄存器（eip）将其指向信号处理函数。

( 用户 )接下来进程返回到用户态中，执行相应的信号处理函数。

( 内核 )信号处理函数执行完成后，还需要返回内核态，检查是否还有其它信号未处理。

( 用户 )如果所有信号都处理完成，就会将内核栈恢复（从用户栈的备份拷贝回来），同时恢复指令寄存器（eip）将其指向中断前的运行位置，最后回到用户态继续执行进程。

## 日志

### 同步日志的缺陷

阻塞主线程：直接调用fwrite/write写入文件时，若 IO 繁忙（如磁盘负载高），会导致业务线程阻塞，影响服务响应速度。

高并发下性能差：多线程同时竞争日志文件句柄，频繁加锁 / 解锁引发线程竞争（如std::ofstream的全局锁问题）。

### 异步日志的核心优势

无阻塞日志生成：业务线程仅需将日志数据写入内存缓冲区，无需等待磁盘 IO 完成。

批量写入提升效率：通过双缓冲区机制，将分散的日志数据合并后批量写入磁盘，减少 IO 次数（如每秒写入一次，而非每条日志触发一次 IO）。

线程安全设计：通过无锁队列或环形缓冲区实现多线程日志投递，避免锁竞争。

# 亮点

## 单例模式

保证一个类仅有一个实例，并提供一个访问它的全局访问点，该实例被所有程序模块共享。

实现思路：私有化它的构造函数，以防止外界创建单例类的对象；使用类的私有静态指针变量指向类的唯一实例，并用一个公有的静态方法获取该实例。

懒汉模式，不用的时候不去初始化，所以在第一次被使用时才进行初始化

饿汉模式，即迫不及待，在程序运行时立即初始化,不管哪个线程调用成员函数getinstance()，都只不过是返回一个对象的指针而已。所以是线程安全的，不需要在获取实例的成员函数中加锁。

```
class single{
private:
    single(){}
    ~single(){}

public:
    static single* getinstance();

};

single* single::getinstance(){
    static single obj;
    return &obj;
}
```

## RAII机制

数据库连接的获取与释放通过RAII机制封装，避免手动释放。

