## 线程池

每个请求对应一个线程方法的不足之一是：为每个请求创建一个新线程的开销很大；为每个请求创建新线程的服务器在创建和销毁线程上花费的时间和消耗的系统资源要比花在处理实际的用户请求的时间和资源更多。

线程池是为了避免创建和销毁线程所产生的开销，避免活动的线程消耗的系统资源；

提高响应速度，任务到达时，无需等待线程即可立即执行；

提高线程的可管理性：线程的不合理分布导致资源调度失衡，降低系统的稳定性。使用线程池可以进行统一的分配、调优和监控。



## I/O复用

### 说⼀下什么是ET，什么是LT，有什么区别？  

1. LT：⽔平触发模式，只要内核缓冲区有数据就⼀直通知，只要socket处于可读状态或可写状态，就会⼀直返 回sockfd；是默认的⼯作模式，⽀持阻塞IO和⾮阻塞IO 

2. ET：边沿触发模式，只有状态发⽣变化才通知并且这个状态只会通知⼀次，只有当socket由不可写到可写或 由不可读到可读，才会返回其sockfd；只⽀持⾮阻塞IO  

###  为什么ET模式不可以⽂件描述符阻塞，⽽LT模式可以呢？  

因为ET模式是当fd有可读事件时，epoll_wait()只会通知⼀次，如果没有⼀次把数据读完，那么要到下⼀次fd 有可读事件epoll才会通知。⽽且在ET模式下，在触发可读事件后，需要循环读取信息，直到把数据读完。如 果把这个fd设置成阻塞，数据读完以后read()就阻塞在那了。⽆法进⾏后续请求的处理。

LT模式不需要每次读完数据，只要有数据可读，epoll_wait()就会⼀直通知。所以 LT模式下去读的话，内核缓 冲区肯定是有数据可以读的，不会造成没有数据读⽽阻塞的情况。  




## 小根堆定时器

### 小根堆定时器与 epoll 如何配合提升性能？

epoll_wait 的超时时间设置为堆顶剩余时间，避免空等待，减少 CPU 空转。
IO 事件处理与超时处理在同一线程循环中，减少线程间通信开销，适合 Reactor 单线程模型或多线程 + 多 epoll 实例模型。

### 如果有大量定时器同时超时，如何避免阻塞主线程？

批量处理优化：在handle_expired_timers中循环处理堆顶超时节点，直到堆顶未超时，避免单次处理过多任务阻塞 IO 事件循环。
异步处理：将耗时的超时回调（如数据库清理）放入线程池执行，主线程仅负责关闭连接和堆结构调整。
